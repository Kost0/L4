# optimizedAPI - Number Sorting API Optimization Project

## Описание проекта

REST API сервис для сортировки массива чисел.

**Основной эндпоинт:**
- `POST /sort` - принимает JSON с массивом чисел и возвращает отсортированный массив

**Пример запроса:**
```json
{
  "numbers": [5, 2, 8, 1, 9]
}
```

---

## Анализ производительности (версия 1.0 - неоптимизированная)

### Результаты нагрузочного тестирования (Vegeta)

**Параметры теста:**
- Rate: 50 req/s
- Duration: 30s
- Total requests: 1500

**Метрики:**

| Метрика | Значение |
|---------|----------|
| Success Rate | 100.00% |
| Mean Latency | 1.306 ms |
| 50th Percentile | 836.254 µs |
| 90th Percentile | 2.522 ms |
| 95th Percentile | 2.718 ms |
| 99th Percentile | 3.453 ms |
| Max Latency | 18.932 ms |
| Throughput | 50.03 req/s |

### CPU Профилирование (pprof - 30s)

**Top горячие точки:**

1. **`handler.bubbleSort`** - **45.83% CPU** (0.66s из 1.44s)
    - Основная вычислительная нагрузка
    - Неэффективный алгоритм O(n²)
    - Возможность оптимизации: замена алгоритма

2. **`encoding/json.(*decodeState).value`** - **21.53% CPU** (0.31s)
    - Десериализация JSON запроса
    - Рекурсивный парсинг структур

3. **`encoding/json.(*decodeState).object`** - **21.53% CPU** (0.31s)
    - Парсинг JSON объектов

4. **`encoding/json.(*Decoder).Decode`** - **25.00% CPU** (0.36s)
    - Общие затраты на JSON декодирование

**Ключевые наблюдения:**
- Bubble Sort - явное узкое место (46% CPU)
- JSON десериализация занимает ~25% CPU

### Benchmark результаты

```
BenchmarkSort-8   	  358591	      4712 ns/op
```

### Оптимизация

**Опираясь на результаты анализа, ключевой проблемой является неэффективный алгоритм сортировки. Для начала заменим его.**

---
## Версия 1.1 - замена алгоритма сортировки

**Изменения:**

- Самописный алгоритм пузырьковой сортировки был заменен на sort.Ints (Pattern-Defeating Quick Sort) 

## Анализ производительности

### Результаты нагрузочного тестирования (Vegeta)

**Параметры теста:**
- Rate: 50 req/s
- Duration: 30s
- Total requests: 1500

**Метрики:**
| Метрика | Значение |
|---------|----------|
| Success Rate | 100.00% |
| Mean Latency | 1.522 ms |
| 50th Percentile | 1.511 ms |
| 90th Percentile | 1.666 ms |
| 95th Percentile | 1.742 ms |
| 99th Percentile | 2.347 ms |
| Max Latency | 4.242 ms |
| Throughput | 50.03 req/s |

### CPU Профилирование (pprof - 30s)

**Top горячие точки:**

1. **`encoding/json.(*Decoder).Decode`** - **37.20% CPU** (0.61s)
    - Общие затраты на JSON декодирование

2. **`encoding/json.(*Decoder).Encode`** - **16.46% CPU** (0.27s)
    - Общие затраты на JSON кодирование

3. **`http(*response).finishRequest`** - **15.85% CPU** (0.26s)
    - Затраты на http ответ

4. **`slices.pdqsortOrdered[go shape it]`** - **11.59% CPU** (0.19s)
    - Значительно улучшена скорость сортировки

### Benchmark результаты

```
BenchmarkSort-8   	  290648	      3514 ns/op
```

### Оптимизация

**Замена алгоритма сортировки значительно улучшила производительность.**
**Теперь главную нагрузку создает обработка JSON. Следующим шагом заменю стандартный json парсер**

---

## Версия 1.2 - замена JSON парсера

**Изменения:**

- Замена стандартного парсера на easyjson

## Анализ производительности

### Результаты нагрузочного тестирования (Vegeta)

**Параметры теста:**
- Rate: 50 req/s
- Duration: 30s
- Total requests: 1500

**Метрики:**

| Метрика | Значение |
|---------|----------|
| Success Rate | 100.00% |
| Mean Latency | 1.062 ms |
| 50th Percentile | 1.169 ms |
| 90th Percentile | 1.401 ms |
| 95th Percentile | 1.55 ms |
| 99th Percentile | 2.261 ms |
| Max Latency | 5.481 ms |
| Throughput | 50.03 req/s |

### CPU Профилирование (pprof - 30s)

**Top горячие точки:**

1. **`handler.easyjson888c126aDecodeGithubComKost0L4InternalHandler`** - **20.59% CPU** (0.21s)
    - Общие затраты на JSON декодирование (заметно лучше)

2. **`syscall.Syscall6`** - **20.59% CPU** (0.21s)
    - Системные вызовы

3. **`http(*response).finishRequest`** - **19.61% CPU** (0.20s)
    - Затраты на http ответ

4. **`handler.RequestPayload.MarshalJSON`** - **13.73% CPU** (0.14s)
    - Общие затраты на JSON кодирование (заметно лучше)

### Benchmark результаты

```
BenchmarkSort-8   	  1587265	      766 ns/op
```

### Оптимизация

**Дальше попробую отказаться от стандартного http пакета в пользу более быстрого**

---

## Версия 1.3 - замена HTTP роутера

**Изменения:**

- Использование fasthttp вместо chi

## Анализ производительности

### Результаты нагрузочного тестирования (Vegeta)

**Параметры теста:**
- Rate: 50 req/s
- Duration: 30s
- Total requests: 1500

**Метрики:**

| Метрика | Значение |
|---------|----------|
| Success Rate | 100.00% |
| Mean Latency | 1.042 ms |
| 50th Percentile | 1.042 ms |
| 90th Percentile | 1.179 ms |
| 95th Percentile | 1.243 ms |
| 99th Percentile | 1.694 ms |
| Max Latency | 3.735 ms |
| Throughput | 50.03 req/s |

### CPU Профилирование (pprof - 30s)

**Top горячие точки:**

1. **`syscall.Syscall6`** - **30.59% CPU** (0.22s)
    - Системные вызовы

2. **`handler.easyjson888c126aDecodeGithubComKost0L4InternalHandler`** - **29.17% CPU** (0.21s)
    - Общие затраты на JSON декодирование

3. **`slices.pdqsortOrdered[go shape it]`** - **11.11% CPU** (0.08s)
    - Затраты на сортировку

4. **`Суммарные затраты fasthttp`** - **9.73** (0.07s)
    - Включает Reset Read Write


### Benchmark результаты

```
BenchmarkSort-8   	  1414960	      858.3 ns/op
```

---

## Итог

В ходе работы над проектом была проведена поэтапная оптимизация REST API сервиса сортировки чисел.

**Сводная таблица результатов (Benchmark)**

| Версия | Оптимизация | ns/op | Прирост (vs v1.0) |
|--------|-------------|-------|-------------------|
| 1.0    | -           | 4712  | -                 |
| 1.1    | PDQSort     | 3514  | 25%               |
| 1.2    | EasyJSON    | 766   | 515%              |
| 1.3    | FastHTTP    | 858*  | 450%              |

*Примечание: Незначительное изменение в ns/op в v1.3 компенсируется снижением нагрузки на GC и уменьшением Max Latency под нагрузкой.

### Ключевые выводы

- Алгоритмическая база (v1.1): Замена Bubble Sort (O(n2)) на PDQSort (O(nlogn)) дала необходимый фундамент. Хотя на малых массивах прирост кажется небольшим, на больших данных это предотвращает экспоненциальный рост времени ответа.

- Узкое место JSON (v1.2): Самый существенный прирост производительности (более 5 раз) дала замена стандартного encoding/json на easyjson. Отказ от рефлексии (reflection) в Go — это одна из самых эффективных оптимизаций для сервисов, активно работающих с сериализацией.

- Работа с сетью (v1.3): Переход на fasthttp позволил снизить накладные расходы на создание объектов запроса/ответа. Это отразилось в стабилизации Max Latency (снижение с 5.4 ms до 3.7 ms) и уменьшении системных вызовов.

### Финальный результат:
Сервис стал работать быстрее в ~5.5 раз (по результатам бенчмарков на операцию) и стабильнее под нагрузкой, избавившись от основных "горячих точек" в профилировщике.